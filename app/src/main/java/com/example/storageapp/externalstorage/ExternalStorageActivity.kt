package com.example.storageapp.externalstorage

import android.Manifest
import android.app.RecoverableSecurityException
import android.content.ContentUris
import android.content.ContentValues
import android.content.pm.PackageManager
import android.graphics.Bitmap
import android.graphics.pdf.PdfRenderer
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.provider.MediaStore
import android.widget.Toast
import androidx.activity.result.ActivityResultLauncher
import androidx.activity.result.IntentSenderRequest
import androidx.activity.result.contract.ActivityResultContracts
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import androidx.lifecycle.lifecycleScope
import com.example.storageapp.databinding.ActivityExternalStorageBinding
import com.example.storageapp.externalstorage.adapter.ExternalImageAdapter
import com.example.storageapp.externalstorage.model.PhotosExternalModel
import com.example.storageapp.internalstorage.adapters.ImageAdapter
import com.example.storageapp.internalstorage.utils.SpacingItemDecorator
import com.example.storageapp.sdk29AndUp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.IOException
import java.util.*

//pdf selection - https://stackoverflow.com/questions/31652173/how-to-list-all-pdf-files-in-my-android-device

class ExternalStorageActivity : AppCompatActivity() {

    private lateinit var permissionsLauncher: ActivityResultLauncher<Array<String>>
    private var readPermissionGranted = false
    private var writePermissionGranted = false
    private lateinit var binding: ActivityExternalStorageBinding
    private lateinit var adapter: ExternalImageAdapter
    private lateinit var intentSenderLauncher: ActivityResultLauncher<IntentSenderRequest>
    private var deletedImageUri: Uri? = null



    private val takePhoto = registerForActivityResult(ActivityResultContracts.TakePicturePreview()) {
        lifecycleScope.launch {
            if(writePermissionGranted){
                if(savePhotoToExternalStorage(UUID.randomUUID().toString(), it)){
                    Toast.makeText(this@ExternalStorageActivity, "Photo saved successfully", Toast.LENGTH_SHORT).show()
                    loadExternalStorageRecyclerview()
                }else{
                    Toast.makeText(this@ExternalStorageActivity, "Failed to save photo", Toast.LENGTH_SHORT).show()
                }
            }
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityExternalStorageBinding.inflate(layoutInflater)
        setContentView(binding.root)

        permissionsLauncher = registerForActivityResult(ActivityResultContracts.RequestMultiplePermissions()) { permissions ->
            readPermissionGranted = permissions[Manifest.permission.READ_EXTERNAL_STORAGE] ?: readPermissionGranted
            writePermissionGranted = permissions[Manifest.permission.WRITE_EXTERNAL_STORAGE] ?: writePermissionGranted
            if(readPermissionGranted) {
               loadExternalStorageRecyclerview()
            } else {
                Toast.makeText(this, "Can't read files without permission.", Toast.LENGTH_LONG).show()
            }
        }

        intentSenderLauncher = registerForActivityResult(ActivityResultContracts.StartIntentSenderForResult()) {
            if(it.resultCode == RESULT_OK) {
                if(Build.VERSION.SDK_INT == Build.VERSION_CODES.Q) {
                    lifecycleScope.launch {
                        deletePhotoFromExternalStorage(deletedImageUri ?: return@launch)
                    }
                }
                Toast.makeText(this@ExternalStorageActivity, "Photo deleted successfully", Toast.LENGTH_SHORT).show()
            } else {
                Toast.makeText(this@ExternalStorageActivity, "Photo couldn't be deleted", Toast.LENGTH_SHORT).show()
            }
        }

        updateOrRequestPermissions()
        setRecyclerView()
        setOnclickListeners()
    }



    private fun setOnclickListeners(){
        binding.imageCamera.setOnClickListener {
            takePhoto.launch(null)
        }
    }

    private fun updateOrRequestPermissions() {
        val hasReadPermission = ContextCompat.checkSelfPermission(
            this,
            Manifest.permission.READ_EXTERNAL_STORAGE
        ) == PackageManager.PERMISSION_GRANTED
        val hasWritePermission = ContextCompat.checkSelfPermission(
            this,
            Manifest.permission.WRITE_EXTERNAL_STORAGE
        ) == PackageManager.PERMISSION_GRANTED
        val minSdk29 = Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q

        readPermissionGranted = hasReadPermission
        writePermissionGranted = hasWritePermission || minSdk29

        val permissionsToRequest = mutableListOf<String>()
        if(!writePermissionGranted) {
            permissionsToRequest.add(Manifest.permission.WRITE_EXTERNAL_STORAGE)
        }
        if(!readPermissionGranted) {
            permissionsToRequest.add(Manifest.permission.READ_EXTERNAL_STORAGE)
        }
        if(permissionsToRequest.isNotEmpty()) {
            permissionsLauncher.launch(permissionsToRequest.toTypedArray())
        }
    }

    private fun setRecyclerView(){
        binding.apply {
            adapter = ExternalImageAdapter(onItemLongClick = {
                lifecycleScope.launch {
                    deletePhotoFromExternalStorage(it.contentUri)
                    deletedImageUri = it.contentUri
                }
            })
            binding.recyclerviewImages.adapter = adapter
            val x = (resources.displayMetrics.density * 2).toInt()
            recyclerviewImages.addItemDecoration(SpacingItemDecorator(x))
            loadExternalStorageRecyclerview()
        }
    }

    private fun loadExternalStorageRecyclerview(){
        lifecycleScope.launch {
            val photos = loadPhotosFromExternalStorage()
            adapter.asyncListDiffer.submitList(photos)
        }
    }

    /**
     *  ContentValues - This class is used to store a set of values that the ContentResolver can process.
     *  EXTERNAL_CONTENT_URI - The content:// style URI for the "primary" external storage volume.
     *  getContentUri(String volumeName) - Get the content:// style URI for the image media table on the given volume.
     *  insert(Uri url, ContentValues values) - Inserts a row into a table at the given URL.
     *  openOutputStream - Open a stream on to the content associated with a content URI.
     *  If there is no data associated with the URI, FileNotFoundException is thrown.
     *
     * */

    private fun savePhotoToExternalStorage(name: String, bitmap: Bitmap?): Boolean {
        val collection = sdk29AndUp {
            MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)
        } ?: MediaStore.Images.Media.EXTERNAL_CONTENT_URI

        val contentValues = ContentValues().apply {
            put(MediaStore.Images.Media.DISPLAY_NAME, "$name.jpg")
            put(MediaStore.Images.Media.MIME_TYPE, "image/jpeg")
            put(MediaStore.Images.Media.WIDTH, bitmap?.width)
            put(MediaStore.Images.Media.HEIGHT, bitmap?.height)
        }
        return try {
            contentResolver.insert(collection, contentValues)?.also { uri ->
                contentResolver.openOutputStream(uri).use { outputStream ->
                    if (!bitmap?.compress(Bitmap.CompressFormat.JPEG, 95, outputStream)!!) {
                        throw IOException("Couldn't save bitmap")
                    }
                }
            } ?: throw IOException("Couldn't create MediaStore entry")
            true
        } catch (e: IOException) {
            e.printStackTrace()
            false
        }
    }

    private suspend fun loadPhotosFromExternalStorage(): List<PhotosExternalModel> {
        return withContext(Dispatchers.IO) {

            val collection = sdk29AndUp {
                MediaStore.Images.Media.getContentUri(MediaStore.VOLUME_EXTERNAL)
            } ?: MediaStore.Images.Media.EXTERNAL_CONTENT_URI

            val projection = arrayOf(
                MediaStore.Images.Media._ID,
                MediaStore.Images.Media.DISPLAY_NAME,
                MediaStore.Images.Media.WIDTH,
                MediaStore.Images.Media.HEIGHT
            )
            val photos = mutableListOf<PhotosExternalModel>()
            contentResolver.query(
                collection,
                projection,
                null,
                null,
                "${MediaStore.Images.Media.DISPLAY_NAME} ASC"
            )?.use { cursor ->
                val idColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media._ID)
                val displayNameColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.DISPLAY_NAME)
                val widthColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.WIDTH)
                val heightColumn = cursor.getColumnIndexOrThrow(MediaStore.Images.Media.HEIGHT)

                while(cursor.moveToNext()) {
                    val id = cursor.getLong(idColumn)
                    val displayName = cursor.getString(displayNameColumn)
                    val width = cursor.getInt(widthColumn)
                    val height = cursor.getInt(heightColumn)
                    val contentUri = ContentUris.withAppendedId(
                        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
                        id
                    )
                    photos.add(PhotosExternalModel(id, displayName, width, height, contentUri))
                }
                photos.toList()
            } ?: listOf()
        }
    }

    private suspend fun deletePhotoFromExternalStorage(photoUri: Uri) {
        withContext(Dispatchers.IO) {
            try {
              contentResolver.delete(photoUri, null, null)
              loadExternalStorageRecyclerview()
            } catch (e: SecurityException) {
                val intentSender = when {
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.R -> {
                        MediaStore.createDeleteRequest(contentResolver, listOf(photoUri)).intentSender
                    }
                    Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q -> {
                        val recoverableSecurityException = e as? RecoverableSecurityException
                        recoverableSecurityException?.userAction?.actionIntent?.intentSender
                    }
                    else -> null
                }
                intentSender?.let { sender ->
                    intentSenderLauncher.launch(
                        IntentSenderRequest.Builder(sender).build()
                    )
                }
            }
        }
    }

}